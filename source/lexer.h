#pragma once

enum {
    TOKEN_TYPE_KEYWORD,
    TOKEN_TYPE_IDENTIFIER,
    TOKEN_TYPE_CONSTANT,
    TOKEN_TYPE_OPERATOR,
    TOKEN_TYPE_SEPARATOR,
    TOKEN_TYPE_STRING_LITERAL,
    TOKEN_TYPE_COMMENT,
    TOKEN_TYPE_UNKNOWN,
    TOKEN_TYPE_CHARACTER_LITERAL
};

enum {
    TOKEN_AUTO,
    TOKEN_CONST,
    TOKEN_DOUBLE,
    TOKEN_FLOAT,
    TOKEN_INT,
    TOKEN_SHORT,
    TOKEN_STRUCT,
    TOKEN_UNSIGNED,
    TOKEN_BREAK,
    TOKEN_CONTINUE,
    TOKEN_ELSE,
    TOKEN_FOR,
    TOKEN_LONG,
    TOKEN_SIGNED,
    TOKEN_SWITCH,
    TOKEN_VOID,
    TOKEN_CASE,
    TOKEN_DEFAULT,
    TOKEN_ENUM,
    TOKEN_GOTO,
    TOKEN_REGISTER,
    TOKEN_SIZEOF,
    TOKEN_TYPEDEF,
    TOKEN_VOLATILE,
    TOKEN_CHAR,
    TOKEN_DO,
    TOKEN_EXTERN,
    TOKEN_IF,
    TOKEN_RETURN,
    TOKEN_STATIC,
    TOKEN_UNION,
    TOKEN_WHILE,
    TOKEN_EXCLAMATION_POINT,
    TOKEN_QUOTE,
    TOKEN_HASHTAG,
    TOKEN_DOLLAR_SYMBOL,
    TOKEN_AMPERSAND,
    TOKEN_OPENING_PARENTHESIS,
    TOKEN_CLOSING_PARENTHESIS,
    TOKEN_NOT_EQUAL_TO,
    TOKEN_PLUS,
    TOKEN_COMMA,
    TOKEN_UNDERSCORE,
    TOKEN_SLASH,
    TOKEN_COLON,
    TOKEN_SEMICOLON,
    TOKEN_SMALLER_THAN,
    TOKEN_QUESTION_MARK,
    TOKEN_AT,
    TOKEN_OPENING_SQUARE_BRACKET,
    TOKEN_CLOSING_SQUARE_BRACKET,
    TOKEN_OR,
    TOKEN_CARET,
    TOKEN_DASH,
    TOKEN_ARMENIAN_COMMA,
    TOKEN_OPENING_BRACKET,
    TOKEN_CLOSING_BRACKET,
    TOKEN_BIGGER_THAN,
};

typedef struct {
    int type;
    char lexeme[128];
} token_t;

token_t** lex(const char* code, int* num_tokens);
void free_tokens(token_t** tokens, int num_tokens);